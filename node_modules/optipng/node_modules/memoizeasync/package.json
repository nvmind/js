{
  "name": "memoizeasync",
  "version": "0.0.1",
  "description": "Helper for memoizing async functions and methods",
  "main": "lib/memoizeAsync.js",
  "directories": {
    "test": "test"
  },
  "dependencies": {},
  "devDependencies": {
    "mocha": "=1.7.3",
    "expect.js": "=0.2.0"
  },
  "scripts": {
    "prepublish": "mocha",
    "test": "mocha"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/papandreou/node-memoizeasync.git"
  },
  "keywords": [
    "memo",
    "memoize",
    "async",
    "cache"
  ],
  "author": {
    "name": "Andreas Lind Petersen",
    "email": "andreas@one.com"
  },
  "license": "BSD",
  "readme": "node-memoizeasync\n=================\n\nYet another memoizer for asynchronous functions.\n\n```javascript\nfunction myExpensiveComputation(arg1, arg2, cb) {\n   // ...\n   cb(null, result);\n}\n\nvar memoized = memoizeAsync(myExpensiveComputation);\n```\n\nNow `memoized` works exactly like myExpensiveComputation, except that\nthe actual computation is only performed once for each unique set of\narguments (apart from the callback):\n\n```javascript\nmemoized(42, 100, function (err, result) {\n    // Got the result!\n\n    memoized(42, 100, function (err, result) {\n        // Got the same result, and much faster this time!\n    });\n});\n```\n\nThe function returned by `memoizeAsync` invokes the wrapped function\nin the context it's called in itself, so `memoizeAsync` even works for\nmemoizing a method that has access to instance variables:\n\n```javascript\nfunction Foo(name) {\n    this.name = name;\n}\n\nFoo.prototype.myMethod = memoizeAsync(function (arg1, arg2, cb) {\n    console.warn(\"Cool, this.name works here!\", this.name);\n    // ...\n    cb(null, \"That was tough, but I'm done now!\");\n});\n```\n\nTo distinguish different invocations (whose results need to be cached\nseparately) `memoizeAsync` relies on a naive stringification of the\narguments, which is looked up in an internally kept hash. If the\nfunction you're memoizing takes non-primitive arguments you might want\nto provide a custom `argumentsStringifier` as the second argument to\n`memoizeAsync`. Otherwise all object arguments will be considered equal\nbecause they stringify to `[object Object]`:\n\n```javascript\nvar memoized = memoizeAsync(function functionToMemoize(obj, cb) {\n    // ...\n    cb(null, Object.keys(obj).join(''));\n}, function argumentStringifier(args) {\n   return args.map(function (arg) {return JSON.stringify(arg);}).join(\",\");\n});\n\nmemoized({foo: 'bar'}, function (err, result) {\n    // result === 'foo'\n    memoized({quux: 'baz'}), function (err, result) {\n        // result === 'quux'\n    });\n});\n```\n\nHad the custom `argumentsStringifier` not been provided, `result`\nwould have been `foo` both times.\n\nCheck out <a\nhref=\"https://github.com/papandreou/node-memoizeasync/blob/master/test/memoizeAsync.js\">the\ncustom argumentsStringifier test</a> for another example.\n\n\nInstallation\n------------\n\nMake sure you have node.js and npm installed, then run:\n\n    npm install memoizeasync\n\nLicense\n-------\n\n3-clause BSD license -- see the `LICENSE` file for details.\n",
  "readmeFilename": "README.md",
  "_id": "memoizeasync@0.0.1",
  "dist": {
    "shasum": "66b9061dc75d0a1bc2ef287660640b2333f4439c"
  },
  "_from": "memoizeasync@=0.0.1",
  "_resolved": "https://registry.npmjs.org/memoizeasync/-/memoizeasync-0.0.1.tgz"
}
